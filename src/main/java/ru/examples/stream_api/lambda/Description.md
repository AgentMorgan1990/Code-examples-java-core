Лямбда-выражение, по существу, является анонимным (т.е. безымянным) методом. Но этот метод не выполняется самостоятельно, 
а служит для реализации метода, определяемого в функциональном интерфейсе. Таким образом, лямбда-выражение приводит к 
некоторой форме анонимного класса. Нередко лямбда-выражения называют также замыканиями. 

Функционалъным называется такой интерфейс, который содержит один и только один абстрактный метод. Как правило, в таком 
методе определяется предполагаемое назначение интерфейса. Следовательно, функциональный интерфейс предсгамяет 
единственное действие. Кроме того, в функциональном интерфейсе определяется целевой тип лямбда-выражения. В связи с этим 
необходимо подчеркнуть следующее: лямбда-выражение можно использовать только в том контексте, в котором определен его 
целевой тип. И еще одно замечание: функциональный интерфейс иногда еще называют SАМ-типом, где SАМ обозначает 
Single Abstract Method - единственный абстрактный метод.

В Java определены две разновидности тел лямбда-выражений. Одна из них состоит из единственного выражения, а другая - из 
блока кода

1) Тело лямбда-выражений в предыдущих примерах состояло из единственного выражения. Такая разновидность тел называется 
телом выражения, а лямбда-выражения с телом выражения иногда еще называют одиночными.

() -> 123.45   -  double myMeth () {return 123.45;}
() -> Math.random() * 100
(n) -> (n % 2)==0

2) Несмотря на все удобство одиночных лямбда-выражений, иногда в них требуется вычислять не одно выражение. Для 
подобныхслучаев в Java предусмотрена вторая разновидность лямбда-выражений, где код, указываемый в правой части 
лямбда-оператора, может состоять из нескольких операторов. Такие лямбда-выражения называются блочными, а их тело - телом блака. 

Обобщенные функциональные интерфейсы

Указывать параметры типа в самом лямбда-выражении нельзя. Следовательно, лямбда-выражение не может быть обобщенным. 
(Безусловно, все лямбда-выражения проявляют в той или иной мере свойства, подобные обобщениям, благодаря выведению 
типов.) А вот функциональный интерфейс, связанный с лямбда-выражением, может быть обобщенным. В этом случае целевой тип 
лямбда-выражения отчасти определяется аргументом типа или теми аргументами, которые указываются при объявлении ссылки 
на функциональный интерфейс.

interface someFunc<T> {
T func(T t);
}

Передача лямбда-выражений в качестве аргументов
Как пояснялось ранее, лямбда-выражение может быть использовано в любом контексте, предоставляющем его целевой тип. Один 
из таких контекстов возникает при передаче лямбда-выражения в качестве аргумента.

Лямбда-выражения и исключения
Лямбда-выражение может генерировать исключение. Но если оно генерирует проверяемое исключение, то последнее должно быть 
совместимо с исключениями, перечисленными в выражении throws из объявления абстрактного метода в функциональном интерфейсе.

Лямбда-выражения и захват переменных (Capturing)
Переменные, определяемые в объемлющей области действия лямбда-выражений, доступны в этом выражении. Например, в 
лябда-выражении можно использовать переменную экземпляра или статическую переменную, определяемую в объемлющем классе.

Но если в лямбда-выражении используется локальная переменная из объемлющей его области действия, то возникает особый 
случай, называемый захватом переменний. В этом случае в лямбда-выражении можно использовать только те локальные 
переменные, которые действителъно являются завершенными. Действительно завершенной считается такая переменная, значение 
которой не изменяется после ее первого присваивания. Такую переменную совсем не обязательно объявлять как final, хотя 
это и не считается ошибкой.

Следует, однако, иметь в виду, что локальная переменная из объемлющей области действия не может быть видоизменена в 
лямбда-выражении. Ведь это нарушило бы ее действительно завершенное состояние, а следовательно, привело бы к 
недопустимому ее захвату.

Следует особо подчеркнуть, что в лямбда-выражении можно использовать и видоизменять переменную экземпляра из вызывающего 
его класса. Но нельзя использовать локальную переменную из объемлющей его области действия, если только эта переменная 
не является действительно завершенной. 

Ссылки на методы
С лямбда-выражениями связано еще одно очень важное средство, называемое ссылкой на метод. Такая ссылка позволяется 
обращаться к методу, не вызывая его. Она связана с лямбда-выражениями потому, что ей также требуется контекст целевого 
типа, состоящий из совместимого функционального интерфейса. Имеются разные виды ссылок на методы.

Ссылки на статические методы
Для создания ссылки на статический метод служит следующая общая форма:
имя_ класса :: имя_метода
outStr = stringOps( MyStringOps::strReverse, inStr);

Ссыпки на методы экэемппяра
ссылка_на_объект::имя_метода

Ссылки на конструкторы
Ссылки на конструкторы можно создавать таким же образом, как и ссылки на методы. Ниже приведена общая форма синтаксиса, 
которую можно употреблять для создания ссылок на конструкторы.
имя_класса :: new

Эта ссьтка может быть присвоена любой ссьтке на функциональный интерфейс , в котором определяется метод, совместимый с 
конструктором. Ниже приведен простой пример применения ссьтки на конструктор. 