Объектно - ориентиравнное програмирование (ООП)
Абстракция

Три принципа ООП
1) Инкапсуляция - механизм, связывающий код и данные, которыми он манипулирует, защищая оба эти компонента от внешнего
вмешательства и злоупотреблений. Основу инкапсуляции в Java составляет класс.

2) Наследование - процесс, в результате которого один объект получает свойства другого.
Суперклассы (родительские классы) и подклассы.
Наследование связано также с инкапсуляцией. Если отдельный класс инкапсулирует определенные свойства, то любой его
подкласс будет иметь те же самые свойства плюс любые дополнительные, определяющие его специализацию. Благодаря этому
ключевому принципу сложность объектно-ориентированных программ нарастает в арифметической, а не геометрической прогрессии.

3) Полиморфизм - ( от греч. "много форм") - это принцип ООП, позволяющий использовать один и тот же интерфейс для
общего класса действий. Каждое действие зависит от конкретной ситуации. В более общем с мысле принцип п олиморфизма
нередко выражается фразой " один интерфейс, несколько методов". Это означает, что можно разработать общий интерфейс
для группы с вязанных вместе действий. Такой подход позволяет уменьшить сложность программы, поскольку один и тот же
интерфейс с лужитдля указания общего класса действий. А выбор конкретного действия (т. е. метода) делается применительно
к каждой ситуации и входит в обязанности компилятора.

Класс
Класс определяет форму и сущность объекта и является логической конструкцией, на основе которой построен весь язык Java.
Наиболее важная особенность класса состоит в том, что он определяет новый тип данных, которым можно воспользоваться для
создания объектов этого типа, т.е. класс — это шаблон (чертеж), по которому создаются объекты (экземпляры класса). Для
определения формы и сущности класса указываются данные, которые он должен содержать, а также код, воздействующий на эти
данные.

Класс определяет структуру и поведение (данные и код), которые будут совместно использоваться набором объектов. Каждый
объект данного класса содержит структуру и поведение, которые определены классом, как если бы объект был "отлит" в форме
класса. Поэтому иногда объекты называют экземплярами класса. Таким образом, класс - это логическая конструкция, а объект
- ее физическое воплощение.

Класс создает новый тип данных, который можно использовать для создания объектов. Это означает, что класс создает
логический каркас, определяющий взаимосвязь между его членами. При объявлении объекта класса создается экземпляр этого
класса. Таким образом, класс - это логическая конструкция, а объект имеет физическую сущность, т.е. он занимает
конкретную область оперативной памяти. Об этом отличии важно помнить.

При создании класса определяются код и данные, которые образуют этот класс. Совместно эти элементы называются
экземплярами класса. В частности, определенные в классе данные называются переменными-членами, или переменными экземпляра,
а код, оперирующий данными, методами-членами, или просто методами.
Открытый интерфейс класса представляет все, что должны или могут знать внешние пользователи класса. Закрытые методы и
данные могут быть доступны только для кода, который является членом данного класса. Следовательно, любой другой код, не
являющийся членом данного класса, не может получать доступ к закрытому методу или переменной. Закрытые члены класса
доступны другим частям программы только через открытые методы класса, и благодаря этому исключается возможность
выполнения неправомерных действий.

Как правило, переменные, объявленные в классе, описывают свойства будущих объектов, а методы - их поведение.
Переменные, объявленные в классе, называются полями экземпляра, каждый объект класса содержит собственные копии этих
переменных, и изменение значения поля у одного объекта никак не повлияет на это же поле другого объекта.
Поля экземпляра и методы, определённые в классе, называются членами класса. В большинстве классов действия над полями
осуществляются через его методы.

Создание объектов класса представляет собой двухэтапный процесс. Сначала следует объявить переменную типа класса. Эта
переменная не определяет объект. Она является лишь переменной, которая может ссылатъся на объект. Затем нужно получить
конкретную, физическую копию объекта и присвоить ее этой переменной. Это можно сделать с помощью оператора new. Этот
оператор динамически (т.е. во время выполнения) резервирует память для объекта и возвращает ссылку на него. В общих
чертах эта ссылка представляет собой адрес объекта в памяти, зарезервированной оператором new. Затем эта ссылка
сохраняется в переменной. Таким образом, оперативная память должна динамически выделяться для объектов всех классов вJava.

Типы классов:
1) Вложенные - это статический класс определённый внутри другого класса
2) Внутренние - это класс внутри класса
3) Локальные - локальный класс, это класс объявленный внутри метода (кодового блока), локальным класссам нельзя
добавлять модификаторы доступа
4) Анонимные -  это класс без имени, реализация которого происходит в текущий момент - при создании "экземпляра"
интерфейса (фактически мы не можем создать его экземпляр, поэтому и появляется анонимный класс), появляется класс без
имени, имя этого класса будет такое же, внутри какого класса его вызвали, например:
Foo foo = new Foo() {
@Override
public void test(){}
}

Анонимный класс необходим для того, чтобы у нас не было необходимости создавать вручную классы под реализацию каждого
варианта метода функционального интерфейса

button.addActionListener(new ActionListener()){
@Override
public void actionPerformed(ActionEvent e){
System.out.println("Hello!");
}}
В данной записи java машина создаёт его по имени текущего класса +$1(номер анонимного класса в классе), и имплементирует
интерфейс, по которому мы хотим "создать" объект например ExampleApp$1 implements ActionListener, мы описываем
реализацию метода и java машина создаёт объект этого класса с переопреопределённым нами методом

Внутренние и вложенные классы
Существует возможность определять один класс в другом классе, в таком случае он будет называться вложенными, и область
его действия будет ограничена областью действия внешнего класса. Так, если класс В определён в кассе А, то класс B не
может существовать независимо от класса А. Вложенный класс имеет доступ к членам (в том числе закрытым) того класса, в
который он вложен. Но внешний класс не имеет доступа к членам вложенного класса. Вложенный класс, объявленный
непосредственно в области действия своего внешнего класса, считается его членом. Классы, объявленные внутри кодовых
блоков, называются локальными.

Существуют два типа вложенных классов: статический и нестатический.
Статическим называется такой вложенный класс, который объявлен с модификатором statiс, поэтому он должен обращаться к
нестатическим членам своего внешнего класса посредством объекта. Это означает, что вложенный статический класс не может
непосредственно ссылаться на нестатические члены своего внешнего класса.
Внутренний класс — это нестатический вложенный класс. Он имеет доступ ко всем переменным и методам своего внешнего
класса и может непосредственно ссылаться на них таким же образом, как это делают остальные нестатические члены внешнего
класса.

У класса может быть блок статической и/или динамической инициализации. Блок статической инициализации выполняется 1 раз
при загрузке программы, блок динамичекой инициализации выполняется при каждом создании нового экземпляра класса.


Методы
В отношении методов важно различать два термина: параметр и аргумент.
Параметр- это определенная в методе переменная, которая принимает заданное значение при вызове метода.
Аргумент - это значение, передаваемое методу при его вызове.


Конструкторы
Для инициализации объектов при создании в Java предназначены конструкторы. Имя конструктора обязательно должно совпадать
с именем класса, а синтаксис аналогичен синтаксису метода.
Конструкторы выглядят не совсем привычно, поскольку они не имеют возвращаемого типа - даже типа void. Это объясняется
тем, что неявно заданным возвращаемым типом конструктора класса является тип самого класса.
Конструкторы бывают двух типов - по умолчанию(без параметров) и параметризированные в которых можно указывать начальные
значения полей наших объектов необходимо создать параметризированный конструктор.

Метод finalize ()
Если объект содержит какой-нибудь ресурс, отличающийся от pecypca java (вроде файлового дескриптора или шрифта) , такой
ресурс, скорее всего, придется освободить перед уничтожением объекта. Для разрешения подобных ситуаций в java
предоставляется механизм, называемый полным завершением. Применяя механизм полного завершения, можно определить
конкретные действия, которые будут выполняться непосредственно перед удалением объекта сборщиком "мусора". Чтобы ввести
в класс средство полного завершения, достаточно определить метод finalize (), который вызывается в исполняющей cpeдe
java непосредственно перед удалением объекта данного класса. В теле метода finalize () нужно указать те действия,
которые должны быть выполнены перед уничтожением объекта.
Следует иметь в виду, что метод finalize () вызывается лишь непосредственно перед сборкой "мусора". Это означает, что
заранее неизвестно, когда будет (и будет ли вообще) выполняться метод finalize (). Поэтому в программе должны быть
предоставлены другие средства для освобождения используемых объектом системных ресурсов и т.п.
Нормальная работа программы не должна зависеть от метода finalize ().

Сокрытие переменной экземпляра
Как известно, в Java не допускается объявление двух локальных переменных с одним и тем же именем в той же самой или в
объемлющей областях действия. Тем не менее допускается существование локальных переменных, включая и формальные
параметры методов, имена которых совпадают с именами переменных экземпляра класса. Но когда имя локальной переменной
совпадает с именем переменной экземпляра, локальная переменная скръюалп переменную экземпляра. Ключевое слово this
позволяет ссьиаться непосредственно на объект, и поэтому его можно применять для разрешения любых конфликтов, которые
могут возникать между переменными экземпляра и локальными переменными в пространстве имен.

Особенносте передачи аргументов (по ссылке или по значению)
Для передачи аргументов подпрограмме в языках программирования имеются два способа.

Вызов по значению - в этом случае значение аргумента копируется в формальный параметр подпрограммы. Следовательно,
изменения, вносимые в параметр подпрограммы, не оказывают никакого влияния на аргумент. (примитивные типы)

Вызов по ссылке - В этом случае параметру передается ссьшка на аргумент, а не егозначение. В теле подпрограммы эта
ссьлка служит для обращения к конкретному аргументу, указанному в вызове. Это означает, что изменения, вносимые в
параметр подпрограммы, будут оказывать влияние на аргумент, используемый при ее вызове. (ссылочные типы)

Все аргументы в Java передаются при вызове по значению, но конкретный результат зависит от того, какой именно тип данных
передается: примитивный или ссьлочный.

Когда метод передается ссылка на объект, сама ссылка передается способом вызова по значению. Но поскольку передаваемое
значение ссылается на объект, то копия этого значения все равно будет ссылаться на тот же самый объект, что и
соответствующий аргумент.



Перегрузка конструкторов
Наряду с перегрузкой обычных методов возможна перегрузка и конструкторов. Мы можем как не объявлять ни одного
конструктора, так и объявить их несколько. Также как и при перегрузке методов, имеет значение набор аргументов, не
может быть нескольких конструкторов с одним и тем же набором аргументов.

Вызов перегружаемых конструкторов по ссылке this ()

Пользуясь перегружаемыми конструкторами, иногда удобно вызывать один конструктор из другого. Для этого в Java имеется
еще одна форма ключевого слова this. В общем виде эта форма выглядит следующим образом:
this (список_аргументов)

MyClass (int i, iпt j) {
а = i;
b = j;
}
MyClass (iпt i) {
this(i, i);
}

Перегруженные методы, когда в метод с одинаковым названием отдаем разное кол-во или типы аргументов, возвращаемые типы
тоже могут быть другими. Например System.out.println() - перегруженные метод, отдаем туда любой тип данных.
Когда в исполняющей cpeдe java встречается вызов перегружаемого метода, в ней просто выполняется тот его вариант,
параметры которого соответствуют аргументам, указанным в вызове.

Аргументы переменной длины
varargs (variable-length arguments - аргументы переменной длины). Метод, который принимает переменное количество
аргументов, называется методом с аргументами переменной длины
static void vaTe st ( int ... v) {}
В этой синтаксической конструкции компилятору предписывается, что метод vaTest ( ) может вызываться без аргументов или
с несколькими аргументами. В итоге массив v неявно объявляется как массив типа int []. Таким образом, в теле метода
vaTest () доступ к массиву v осуществляется с помощью синтаксиса обычного массива.

Наряду с параметром переменной длины у метода могут быть и "обычные" параметры. Но параметр переменной длины должен быть
последним среди всех параметров, объявляемых в методе. Например, следующее объявление метода вполне допустимо:
int doi t ( int а, int Ь, douЫe с, int ... vals) {}

Перегрузка методов с аргументами переменной длины
Есть два варианта
Первый способ состоит в том, что у параметра данного метода с переменным количеством аргументов могут быть разные типы.
Именно это имеет место в вариантах метода vaRest (int ... v) и vaTest (boolean ... v).
Второй способ перегрузки метода с аргументами переменной длины состоит в том, чтобы добавить один или несколько обычных
параметров. Именно это и было сделано при объявлении метода vaTest (String msg, int ... v )

Метод, поддерживающий переменное количество аргументов, может быть также перегружен методом, который не поддерживает
такую возможность. Так, в приведенном выше примере программы метод vaTest () может быть перегружен методом vaTest (int х).
Этот специализированный вариант вызывается только при наличии аргумента int.
Если же передаются два или более аргумента типа int, то будет выбран вариант метода vaTest (int ... v) с аргументами переменной длины.

Аргументы переменной длины и неоднозначность
При перегрузке метода, принимающего аргументы переменной длины, могут происходить непредвиденные ошибки. Они связаны с
неоднозначностью, которая может возникать при вызове перегружаемого метода с аргументами переменной длины.
Пример 1
vaTest (int ... v)
vaTest (boolean ... v)

vaTest (1, 2, 3 ) ; // Верно !
vaTest (true, false, false) ; // Верно !
vaTest () ; // Ошибка : неоднозначность !

Пример 2
static void vaTest ( int ... v) { //...
static void vaTest ( int n, int ... v) { // ...

vaTest (1) // Ошибка : неоднозначность !


Поля объектов инициализируются по умолчанию
Локальные переменные по умолчанию не инициализируются и должны быть проинициализированы вручную


Наследование
Одним из основополагающих принципов ООП является наследование, который позволяет создать класс (суперкласс),
определяющий какие-то общие черты набора классов, а затем этот общий класс может наследоваться другими, более
специализированными классами (подклассами), каждый из которых будет добавлять свои особые характеристики. Подкласс
наследует члены, определённые в суперклассе, добавляя к ним собственные.

Подкласс будет наследовать члены, определённые в суперклассе, в соответствии с модификаторами доступа этих членов. Если
у суперкласса будет private поле, то подкласс не унаследует это поле.

Для реализации наследования используется ключевое слово extends

Для каждого создаваемого класса можно указать только один суперкласс — в Java не поддерживается множественное
наследование. Если суперкласс не указан явно, то класс наследуется от класса java.lang.Object

Ключевое слово super
У ключевого слова super имеются две общие формы. Первая служит для вызова конструктора суперкласса, вторая — для
обращения к члену суперкласса, скрываемому членом подкласса.

1) Из подкласса можно вызывать конструктор, определенный в его суперклассе, используя следующую форму ключевого слова
super: super(список_аргументов)
Вызов метода super() всегда должен быть первым оператором, выполняемым в конструкторе подкласса. Если в конструкторе
подкласса явно не использовать super(), то автоматически первой строкой будет вызываться конструктор по умолчанию из
суперкласса.
Такая конструкция позволяет заполнять даже поля суперкласса с модификатором доступа private.

2) Вторая форма применения ключевого слова super действует подобно ключевому слову this, за исключением того, что ссылка
всегда делается на суперкласс. Вторая форма наиболее пригодна в тех случаях, когда имена членов подкласса скрывают члены
суперкласса с такими же именами

public void test() {
z = 10; // Обращение к полю z класса Подкласса
super.z = 20; // Обращение к полю z Суперкласса
}
КРАЙНЕ НЕ РЕКОМЕНДУЕТСЯ объявлять поля с одинаковыми именами в суперклассе и его подклассах, потому как очень легко будет
запутаться с каким из полей вы работаете. Такое объявление переменных имеет только если вы без этого никак не можете
обойтись, и абсолютно четко понимаете что делаете.

Наследники не должны обращатся к полям родителе через геттеры и сеттеры, для прямого дуступа наследниками можем выбирать
между вариантами default и protected в зависимости от ситуации, например если мы сами отвечаем за этот класс и
располагаем его в отдельном пакете, то логично воспользоваться default. Если наследники и родитель потенциально могут
лежать в разных пакетах, пользуемся protected.
В наследниках не надо дублировать поля из родительского класса.
Родитель - суперкласс, наследник - подкласс.

Порядок вызова конструкторов
Конструкторы вызываются в порядке наследования, поскольку суперклассу ничего неизвестно о своих подклассах, и поэтому
любая инициализация должна быть выполнена в нём совершенно независимо от любой инициализации, выполняемой подклассом.
Следовательно, она должна выполняться в первую очередь.

Переопределение методов
Если у супер- и подкласса совпадают сигнатуры методов, то говорят, что метод из подкласса переопределяет метод из
суперкласса. Когда переопределённый метод вызывается из своего подкласса, он всегда ссылается на свой вариант,
определённый в подклассе. А вариант метода, определённого в суперклассе, будет скрыт.

Над методами подклассов, переопределяющими методы суперклассов, можно ставить аннотацию @Override, но она не является
обязательной. Она всего лишь проверит, действительно ли в родительском классе есть такой метод, который вы собрались
переопределять.

Если при переопределении метода необходим функционал из этого метода суперкласса, то можно использовать конструкцию
super.method().

Переопределение методов выполняется только в том случае, если имя, список аргументов и возвращаемый тип обоих методов
одинаковы. В противном случае оба метода считаются перегруженными.
Переопределенные методы позволяют поддерживать в Java полиморфизм во время выполнения, он позволяет определить в общем
классе методы, которые станут общими для всех производных от него классов, а в подклассах — конкретные реализации
некоторых или всех этих методов.
ключевое слово instanceof - помогает определить является ли текущий объект объектом такого-то класса

Динамическая диспетчеризация методов
Переопределение методов служит основой для одного из наиболее эффективных принципов в Java - динамической
диспетчерезации методов. Динамическая диспетчеризация методов - это механизм, с помощью которого вызов переопределенного
метода разрешается во время выполнения, а не компиляции. Динамическая диспетчеризация методов важна потому, что
благодаря ей полиморфизм в Java реализуется во время выполнения.
По ссылке на разные типы объектов будут вызываться разные варианты переопределенного метода. Иначе говоря, вариант
переопределенного метода выбирается для выполнения в зависимости от типа объекта, на который делается ссылка а не типа
ссылочной переменной. Так, если суперкласс содержит метод, переопределяемый в подклассе, то по ссылке на разные типы
объектов через ссылочную переменную из суперкласса будут выполняться разные варианты этого метода.





Абстрактные классы и методы
Если требуется определить суперласс таким образом, чтобы объявить в нём структуру заданной абстракции, не предоставляя
полную реализацию каждого метода, то для этой цели служит абстрактный метод (с модификатором abstract). Иногда они
называются методами под ответственностью подкласса, поскольку в суперклассе для них никакой реализации непредусмотрено,
и они обязательно должны быть переопределены в подклассе. abstract void voice();
При указании ключевого слова abstract в объявлении метода, тело метода будет отсутствовать. Класс, содержащий хоть один
абстрактный метод, должен быть объявлен как абстрактный (в объявлении класса также добавляется ключевое слово abstract).

Нельзя создавать объекты абстрактного класса, поскольку он определён не полностью. Кроме того,нельзя объявлять
абстрактные конструкторы или абстрактные статические методы. Любой подкласс, производный от абстрактного класса, обязан
реализовать все абстрактные методы из своего суперкласса (при условии что подкласс сам не является абстрактным). При
этом абстрактный класс вполне может содержать конкретные реализации методов.


Класс Object
Абсолютно все классы в Java наследуются от класса java.lang.Object
Методы класса Object

Object clone ()                     - Создает новый объект, не отличающийся от клонируемого

boolean equals (Object object)      - описывает, как сравнивать объекты. Метод equals() в классе Object, по-умолчанию
сравнивает пару объектов просто через оператор ==. Поэтому необходимо переопределять этот метод в наших классах.

void finalize ()                    - Вызывается перед удалением неиспользуемого объекта

Class<?> qetClass ()                - Получает класс объекта во время выполнения

int hashCode ()                     - Возвращает хеш-код, связанный с вызывающим объектом

void notify ()                      - Возобновляет исполнение потока, ожидающего вызывающего объекта

void notifyAll ()                   - Возобновляет исполнение всех потоков, ожидающих вызывающего объекта

String toString ()                  - Возвращает символьную строку, описывающую объект

void wait ()                        - Ожидает другого потока исполнения
void wait (long миллисекунд)
void wait (long миллисекунд, int наносекунд)

Методы getClass (), notify (), notifyAll () и wait () объявлены как final. Остальные методы можно переопределять.

При переопределении методов hashCode() и equals() необходимо обязательно придерживаться следующего:
- Если объекты равны через метод equals(), то их hashCode() обязательно должны быть равны;
- Если объекты не равны по equals(), то желательно чтобы их hashCode() отличались,

Назначение пакетов
1) Помогют логически группировать классы
2) Помогают в инкапсюляции
3) Решение конфликта имён
Если хотим воспользоваться классами с одинаковыми именами в одном классе, необходимо прописывать полное имя класса
Если мы используем классы из того же пакета, то импорты добалять не нужно

Оператор package имеет следующую общую форму:
package пакет;

Оператор import
Поскольку программировать на Java бесполезно без многих средств, определенных в пакете java.lang, компилятор неявно
импортирует его для всех программ. Это равнозначно наличию следующей строки кода в каждой из программ нa java:
import java.lang.*;

Следует особо подчеркнуть, что указывать оператор import совсем не обязательно. Полностъю утачненное имя класса с
указанием всей иерархии пакетов можно использовать везде, где допускается имя класса.
class MyDate extends java.util.Date

Статический импорт
Благодаря статическому импорту появляется возможность ссылаться на статические члены непосредственно по именам, не
угочняя их именем класса. Это упрощает и сокращает синтаксис, требующийся для работы со статическими членами.

Имеются две основные формы оператора import static.

1) Первая форма, употреблявшаяся в предыдущем примере программы, делает
видимым единственное имя. В общем виде эта форма статического импорта такова:

import static  пакет.имя_типа.имя_статического_члена;

2) Вторая форма статического импорта позволяет импортировать все статические члены данного класса или интерфейса. В
общем виде эта форма выглядит следующим образом:
import static пакет.имя_типа.*;

Каким бы удобным ни был статический импорт, очень важно не злоупотреблять им. Не следует забывать, что библиотечные
классы Java объединяются в пакеты для того, чтобы избежать конфликтов пространств имен и непреднамеренного сокрытия
прочих имен. Если статический член используется в прикладной программе только один или два раза, то его лучше не
импортировать. К тому же некоторые статические имена, как, например, System.out, настолько привычны и узнаваемы, что их
вряд ли стоит вообще импортировать. Статический импорт следует оставить на тот случай, если статические члены применяются
многократно, как, например, при выполнении целого ряда математических вычислений. В сущности, этим языковым средством
стоит пользоваться, но только не злоупотреблять им.

Интерфейсы
С помощью ключевого слова interface можно полностью абстрагировать интерфейс класса от его реализации, то есть указать,
что именно должен выполнять класс, но не как это делать.

Синтаксически интерфейсы аналогичны классам, но не содержат переменные экземпляра, а объявления их методов, как правило,
не содержат тело метода. Каждый интерфейс может быть реализован любым количеством классов. Кроме того, один класс может
реализовать любое количество интерфейсов. Чтобы реализовать интерфейс, в классе должен быть переопределён весь набор
методов интерфейса.

Интерфейсы изолируют определение метода или набора методов от иерархии наследования. А поскольку иерархия интерфейсов не
совпадает с иерархией классов, то классы, никак не связанные между собой иерархически, могут реализовать один и тот же
интерфейс. Именно в этом возможности интерфейсов проявляются наиболее полно.

Методы интерфейса имеют модификаторы public и abstract (даже если вы это явно не указали). Каждый класс, реализующий
интерфейс, должен переопределить (реализовать) все его методы.

В интерфейсах могут быть объявлены поля, они неявно будут иметь модификаторы public static final, и обязательно должны
быть инициализированы, то есть на самом деле это глобальные константы (одно из отличий от абстрактного клсса)

Доступ к реализациям через ссыпки на интерфейсы
Переменные можно объявлять как ссылки на объекты, в которых используется тип интерфейса, а не тип класса.
Callback с= new Client ();
Поскольку в Java динамический поиск методов во время выполнения сопряжен со значительными издержками по сравнению с
обычным вызовом методов, в прикладном коде, критичном к производительности , интерфейсы следует использовать только
тогда, когда это действительно необходимо.
Переменная ссылки на интерфейс располагает только сведениями о методах, объявленных в том интерфейсе, на который она
ссылается.

Частичные реализации
Если класс включает в себя интерфейс, но не полностью реализует определенные в нем методы, он должен быть объявлен как
abstract.

Вложенные интерфейсы
Интерфейс может быть объявлен членом класса или другого интерфейса. Такой интерфейс называется иитерфейсом-членом или
вложенным иитерфейсом.
Вложенный интерфейс может быть объявлен как public, private или protected. Этим он отличается от интерфейса верхнего
уровня, который должен быть объявлен как public или использовать уровень доступа по умолчанию, как отмечалось ранее.
Когда вложенный интерфейс используется за пределами объемлющей его области действия, его имя должно быть дополнительно
уточнено именем класса или интерфейса, членом которого он является. Это означает, что за пределами класса или интерфейса,
в котором объявлен вложенный интерфейс, его имя должно быть уточнено полностью.

Если родитель имплементит интерфейс, то и все наследники по дефолту имплементят его, а аму реализацию интерфейса можно
переопределить и в наследниках

Переменные в интерфейсах
Интерфейсы можно применять для импорта совместно используемых констант в несколько классов пугем простого объявления
интерфейса, который содержит переменные, инициализированные нужными значениями. Когда интерфейс включается в класс
(т.е. реализуется в нем), имена всех этих переменных оказываются в области действия констант. Если интерфейс не содержит
никаких методов, любой класс, включающий в себя такой интерфейс, на самом деле ничего не реализует. Это все равно, как
если бы класс импортировал постоянные поля в пространство имен класса в качестве завершенных переменных.
interface SharedConstants {
int NO = О;
int YES = 1;
int МАУВЕ = 2;
int LATER = 3;
int SOON = 4;
int NEVER = 5;
}
Упомянутая выше методика применения интерфейса для определения общих констант весьма противоречива и представлена ради
полноты изложения материала.

Расширение интерфейсов
Ключевое слово extends позволяет одному интерфейсу наследовать другой. Синтаксис определения такого наследования
аналогичен синтаксису наследования классов. Когда класс реализует интерфейс, наследующий другой интерфейс, он должен
предоставлять реализации всех методов, определенных по цепочке наследования интерфейсов.

Методы по умолчанию (метод расширения)
Метод по умолчанию позволяет теперь объявлять в интерфейсе метод не абстрактным, а с конкретным телом.
Причины обавления метода по умолчанию:
1) Стремление предоставить средства, позволявшиеся расширять интерфейсы, не нарушая уже существующий код.
2) Стремление указывать в интерфейсе, по существу, необязательные методы в зависимости от того, каким образом и
спользуется интерфейс. Нпример, реализация метода remove() в части реализующих его классом был пустым. А теперь
реализацию по умолчанию метода remove(), не выполняющего никаких действий или генерирующего исключение, можно указать в
интерфейсе.

Важно отметить, что внедрение методов по умолчанию не изменяет главную особенность интерфейсов: неспособность сохранять
данные состояния. В частности, в интерфейсе по-прежнему недопустимы переменные экземпляра. Следовательно, интерфейс
отличается от класса тем, что он не допускает сохрапение состояния. Более того, создавать экземпляр самого интерфейса нельзя.

Метод по умолчанию определяется в интерфейсе таким же образом, как и метод в классе. Главное отличие состоит в том, что
в начале объявления метода по умолчанию указывается ключевое слово default.

Логично при добавлении метода по умолчанию иногда выкидывать UnsupportedOperationException.

Вопросы множественного наследования
Решение конфликта имён при реализации интерфейсов с одинаковым названием метододов
1) Во всех подобных случаях приоритет отдается реализации метода в классе над его реализацией в интерфейсе.
2) Если в классе реализуются два интерфейса с одинаковым методом по умолчанию, но этот метод не переопределяется в
данном классе, то возникает ошибка.
3) В тех случаях, когда один интерфейс наследует другой и в обоих интерфейсах определяется общий метод по умолчанию,
предпочтение отдается варианту метода из наследующего интерфейса. Так, если интерфейс Beta расширяет интерфейс Alpha, то
используется вариант метода reset () из интерфейса Beta. Впрочем, используя новую форму ключевого слова super, вполне
возможно ссылаться на реализацию по умолчанию в наследуемом интерфейсе.
Так, если из интерфейса Beta требуется обратиться по ссылке к методу по умолчанию reset() в интерфейсе Alpha, то для
этого достаточно воспользоваться следующим оператором: Alpha.super.reset ();

Так же как и в классах, помимо обычных методов, в интерфейсах можно объявлять статические методы.
Статические методы из интерфейсов не наследуются ни реализующими их классами, ни подчиненными интерфейсами.

Типы интерфейсов:
1) Маркерные - пустой интерфейс, например Serializable
2) Функциональные - с одним не дефолтным методом (абстратным)

В интерфейсах можно инициализировать поля, но изменять их уже нельзя - они final
В интерфейсе могут быть дефолтные методы (default)


Перечисления (ENUM)
Это список именованных однотипных констант, определяющих новый тип данных, в объектах которого
могут храниться только значения из этого списка.
Для создания перечислений используется ключевое слово enum.

В Java перечисления реализованы как типы классов, и отличаются от обычных классов отсутствием необходимости использовать
оператор new, и тем, что enum не могут выступать в роли супер- и подклассов.

Во всех перечислениях присутствуют методы: values() — возвращает массив, содержащий список констант, и
valueOf(String str) — константу перечисления, значение которой соответствует строке аргументу str.

Конструкторы, методы, переменные экземпляра и перечисления
В перечислении каждая константа является объектом класса данного перечисления. Таким образом, перечисление может иметь
конструкторы, методы и переменные экземпляра. Если определить для объекта перечислимого типа конструктор, он будет
вызываться всякий раз при создании константы перечисления. Для каждой константы перечисляемого типа можно вызвать любой
метод, определённый в перечислении. Кроме того, у каждой константы перечисляемого типа имеется собственная копия любой
переменной экземпляра, определённой в перечислении


