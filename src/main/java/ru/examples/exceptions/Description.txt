Возникновение объектов типа Error или одного из его подклассов, означает что в процессе выполнения программы  возникли
серьезные проблемы, которые не получится перехватить, обработать и каким-то образом поправить. Они используются для
обозначения ошибок, происходящих в самой исполняющей среде (например, при переполнении стека (StackOverflowError)).

Исключения (Exceptions) также представляют собой объекты, генерируемые во время появления ошибочных ситуаций и
содержащие информацию о них, но в отличие от Error, исключения могут быть перехвачены программой, обработаны, что
предотвратит завершение работы приложения. Все исключения можно разделить на две группы:

Класс Exception и его подклассы: исключения, которые обязательно должны быть перехвачены программой (Checked)

Класс RuntimeException и его подклассы: исключения, охватывающие такие ситуации, как деление на ноль или ошибочная
индексация массивов (Unchecked).

Обработать исключение можно одним из двух способов:
● Поместить код, бросающий исключение, в блок try-catch.
● Пробросить исключение методу на уровень выше, то есть методу, который вызывает текущий метод. Для этого используется
ключевое слово throws.

Но есть и третий путь: вообще не обрабатывать исключение.
Любое исключение, не перехваченное прикладной программой, в конечном итоге будет перехвачено и обработано стандартным
обработчиком. Стандартный обработчик выводит символьную строку с описанием исключения и результат трассировки стека,
начиная с момента возникновения исключения, а затем прерывает выполнение программы.


Как видно из раскраски рисунка 1, существует две группы
исключений:
● Checked исключения — если в коде происходит такое исключение, его обязательно нужно обработать одним из двух
вышеописанных способов. Если checked исключение оставить в коде “как есть”, то есть без try-catch и throws, то
возникнет ошибка на этапе компиляции.

● Unchecked исключения — их можно обрабатывать если есть вероятность возникновения. А можно и не обрабатывать, поскольку
предполагается, что при правильном поведении программы такие исключения вовсе не должны возникать. Действительно, если
массив состоит из 8 элементов, то код не должен обращаться к десятому. Или любое деление на переменную типа int надо
было бы обязательно проверять на появление ArithmeticException.

В классе Throwable определен метод printStackTrace()

Применяя несколько операторов catch, вы должны помнить, что перехват исключений из подклассов должен следовать до
перехвата исключений из суперклассов. Дело в том, что оператор саtch, в котором перехватывается исключение из
суперкласса, будет перехватывать все исключения этого суперкласса, а также всех его подклассов. Это означает, что
исключения из подкласса вообще не будут обработаны, если попытаться перехватить их после исключений из его суперкласса.
Кроме того, недостижимый код считается в Java ошибкой.

Оператор throw
Исключения можно генерировать и непосредственно в прикладной программе с помощью оператора throw. Его общая форма
выглядит следующим образом:

throw генерируемый_экземпляр;

Здесь генерируемый экземпляр должен быть объектом класса Throwable или производного от него подкласса

Оператор throws
Если метод способен вызвать исключение, которое он сам не обрабатывает, то он должен задать своё поведение таким
образом, чтобы вызывающий его код мог обезопасить себя от такого исключения. С этой целью в объявление метода вводится
оператор throws, где перечисляются типы исключений, которые метод может генерировать. В таком случае обычно говорят что
метод “пробрасывает” указанные исключения. Ниже приведена общая форма объявления метода, которая включает оператор throws.

Оператор finally
Оператор finally образует блок кода, который будет выполнен по завершении блока операторов try/catch, но перед следующим
за ним кодом, он выполняется независимо от того, было ли сгенерировано исключение или нет, было ли оно перехвачено
блоком catch или нет. Это может быть удобно для закрытия файловых дескрипторов, либо освобождения других ресурсов,
которые были выделены в начале метода и должны быть освобождены перед возвратом из него. Блок finally не является
обязательным, но каждому оператору try требуется хотя бы один оператор catch или finally.

Создание собственных подклассов исключений
Для создания собственного класса исключений достаточно определить его как производный от любого класса-исключения
(Exception, RuntimeException, IOException, NullPointerException и др.), его “группа” (checked или unchecked) будет такой
же как и “группа” суперкласса. В собственных классах исключений даже не обязательно добавлять какие-либо поля или методы,
их присутствия в системе типов уже достаточно, чтобы пользоваться ими как исключениями.
