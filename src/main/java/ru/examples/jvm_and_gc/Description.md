При компиляции один класс = один файл.

В проекте может быть сколько угодно main методов, но в одном классе не более одного и при сборке проекта в манифесте 
необходимо указывать какой именно main метод из проекта запускать.

JRE (Java runtime environment) - достаточно для запуска программ на java. Входит:
- JVM
- Платформенные классы Core (java.lang.Object и т.п) , Java standard API(io, net, awt, swing и т.п.)
- реализация нативных методов платформенных классов (которые написаны не на java, например на С, С++)
- вспомогательные файлы

JDK (Java development kit) включает в себя JRE + инструменты разработки (компилятор?)

Загрузка классов производится в момент выполнения, а не компиляции.
Загрузка классов производится из:
- JRE
- из classpath приложения
- автосгенерированные на лету
- предоставленные самим приложением 

Классы загружаются с помощью ClassLoader -ов:
- Bootstrap ClassLoader - платформенные классы, создаётся при старте JVM, реализован в нативном коде из rt.jar
- Extension ClassLoader - загрузка классов из каталога jre/lib/ext
- Application ClassLoader (System ClassLoader) - классы из classpath приложения и собственные классы приложения
- Можно создавать свои загрузчики (например может быть прменим для разработки на фронте тренажёра по java, javarush и т.п.)

Процесс загрузки класса:
- загрузка - загрузка класса из файла в память java машины
- верификация - проверка, что класс соответсвует стандартам языка java и спецификациям jvm
- подготовка - подготовка структуры данных для выделения необходимой памяти под объекты данного класса, проверка полей 
методов, интерфейсов. в metaspace (часть heap-а) (PermaGen) создаётся runtime представление класса
- резолвинг - разрешение всех символьных ссылок на пул констант
- инициализация - подготовка полей класса. Выполнение статических блоков инициализации и заполнение статических полей.
- загрузка суперклассов и суперинтерфейсов

Когда загружается классы:
- Создание объекта (new)
- Обращение к статическому методу класса
- Вызов статического метода класса
- Вызоа метода Class.forName
- * Создание его наследников

Выделение памяти:
- При вызове оператора new - jvm делает системный вызов с запросом на выделение памяти для объекта. Для минимизации кол-ва 
системных вызовов jvm заправишивает память не под один объект, а сразу под несколько и следит за тем, как тратится память 
при создании ещё нескольких объектов, сдвигает границы (аллокация методом подвижной границы)
- Аллокация объектов потокобезопасна и неблокирующая - каждый поток работает со своим куском памяти (Thread local heap)

Layout(разметка) Java объектов (как java объект выглядит в памяти)
- java object header - содержит в себе указатель на класс, монитор(lock), identity hashcode, флаги для GC
- поля (могут быть переупорядочены в зависимости от архитектуры OS)

Старт JVM
- системным загрузчиком грузится main класс и производится загрузка платформенных классов
- выполняется main метод

Компиляторы
- бывают не оптимизирующие, простые оптимизирующие, сложные оптимизирующие. От сложности зависит скорость загрузки, но повышение скорости работы.
- способы компиляции бывают динамичские(Just-In-Time JIT трансляция байт-кода в машинны код в момент выполнения) и статические(Ahead-On-Time AOT до исполнения программы)

Чем дольше исполняется код, тем он становится более оптимизированныйм, этим занимается профилировщик JIT - компилятора (собирает информации об исполнении и оптимизирует её)
Существует 4 уровня оптимизации (Native level 1, native level 2,  native level 3,  native level 4)
Code cash - особо тяжёлые куски кода хранятся в кэше, чтобы не компилировать ещё раз - данная операция становится равноценны вызову нативного метода

Рефлексия (Reflection API)
- помогает получить доступ к классам, полям и методам в процессе выполнения программы
- реализуется в JVM через доступ в Meta Space
- ключевая возможность для многих java фреймворков (например аннотации, подменв кода класса)


Платформенно-ориентированные методы
Иногда, хотя и редко, возникает потребность вызвать подпрограмму, написанную на другом языке, а не на Java.
Для объявления платформенно-ориентированных методов в java предусмотрено ключевое слово native . Однажды объявленные 
как native, эти методы могут быть вызваны из прикладной программы нa java таким же образом, как и вызывается любой 
другой метод.
public native int meth ();
Большинство платформенно-ориентированных методов пишутся на С. Механизм интеграции кода на с и программы на Java 
называется интерфейсом JNI (Java Native Interface).

Java Native Interface(JNI)
- связывает JVM с внешним миром (ОС)
- Си интерфейс к JVM (не зависит от реализации JVM, используется при реализации native методовна языке Си (или другом 
системном языке), с помощью JNI написаны платформо-зависимые реализации Java SE API; io, net, awt)
- реализуется в JVM как доступ в Meta Space 

Под каждую платформу в JVM свои реализации нативных методов, если мы будем писать методы используя этот интерфейс, то 
пострадает кросс-платформенность, будет работать только на одном типе операционных систем
Возможно использовать для точечной оптимизации процессов (используется, например, в libGDX)

Трудности, связан ные с платформенноориентированными методами
1) Потенциальный риск нарушения безопасности.
2) Потеря переносимости.


Garbage collector
Что не является мусором:

1) Корневое множество объектов(GC Roots)
- объекты в статических полях классов
- объекты доступные из стека java потоков
- объекты из JNI ссылок в нативных методах

2) Живые объекты
- объекты из корневого множества
- объекты, на которые ссылаются живые объекты
остальное - мусор

Трассирующие сборщики 
marc-and-sweep - помечает живые объекты и удаляет мусор
stop-and-copy - копирует живые объекты в специальное место,освободивщееся место используется для аллокации новых объектов

поскольку сборщик мусора может переложить объект в памяти, поэтому мы и не можем получать прямую ссылку на объект, в отличае от C++

Stop the world
Живые объекты определены для определённого момента исполнения программы и меняется с течением времени
чтобы собрать мусор необходимо остановить потоки для определения мусора(stw пауза)

для уменьшения паузы есть несколько методов:
- инкрементальный - сбирать не весь мусор в паузе
- параллельный - собирать мусор во многих потоках в паузе
- одновременный - собирать мусор в моменте выполнения

Поколенная сбока мусора
большинство объектов умирает молодыми
старые объекты редко ссылаются на молодые

Поколенный (generational) GC - частный вид инкрементального, на малых сборках удаляем мусор среди молодых объектов, 
объекты пережившие несколько сборок переносим в область старого поколения

Manageability & Monitoring
JVM знает про программу всё про загруженные классы, про живые объекты, про потоки, исполняемы методы потоков

Для того, чтобы можно было получить эту информацию можно пользоваться JVM Tool Interface(JVM TI)
отладчиками и профилировщиками

Java Management Beans - инструменты мониторинга запущенных приложений:
- JConsole, JMX console, AMC
- Visual JVM
- Java Mission Control



