Обобщения - это параметризованные типы.
Классы, интерфейсы и методы, оперирующие переметризованными типами назваются обобщенными.

Прежде чем продолжить дальше, следует сказать, что компилятор Java на саиом деле не создает разные версии класса Gen или 
любого другого обобщенного класса. Теоретически это было бы удобно, но на прцтике дело обстоит иначе. Вместо этого 
компилятор удаляет все сведения об обобщенрых типах, выполняя необходимые операции приведения типов, чтобы сделать 
поведение прикладного кода таким, как будто создана конкретная версия класса Gen. Таким образом, имеется только одна 
версия класса Gen, которая существует в прикладной программе. Процесс удаления обобщенной информации об обобщенных 
типах называется стиранием.

Обобщения действуют только со ссылочными типами, если нужно работать с примитивами, пользуемся оболочками с 
автоупаковкой и распаковкой.

Обобщен ныетипы различаются по аргументам типа

Возможность создавать типизированный (т.е. обеспечивающий типовую безопасность) код, в котором ошибки несоответствия 
типов перехватыва.Ются компилятором, является главным преимуществом обобщений.
По существу, благодаря обобщениям ошибки, возникающие во время выполнения, преобразуются в ошибки, обнаруживаемые во 
время компиляции. В этом и заключается главное преимущество обобщений. 

Обобщенный класс с двумя параметрами типа
Для обобщенного типа можно об'Ьявлять не только один параметр. Два или бо11-ее параметра типа можно указать списком 
через запятую
class TwoGen<T , V>

Ограниченные типы
Указывая параметр типа, можно наложить ограничение сверху в виде верхней границы, где объявляется суперкласс, от 
которого должны быть унаследованы все аргументы типов. С этой целью вместе с параметром указывается ключевое слово
extends , как показано ниже.
<Т extends суперкласс>
Это означает, что параметр типа Т может быть заменен только указанным суперклассом или его подклассами. Следовательно, 
суперкласс объявляет верхнюю границу включительно. Это онраничение позволяет нам пользоватся всеми методами суперкласса.

В виде ограничения можно накладывать не только тип класса, но и тип интерфейса. Более того, такое ограничение может 
включать в себя как тип класса, так и типы одного или нескольких интерфейсов. В этом случае тип класса должен быть задан 
первым. Когда ограничение включает в себя тип интерфейса, допустимы только аргументы типа, реализующие этот интерфейс. 
Накладывая на обобщенный тип ограничение, состоящее из класса и одного или нескольких интерфейсов, д.Тlя их объединения 
следует воспользоваться логической операцией &:
class Gen<T extends MyClass & MyInterface> { // ...
где параметр типа Т ограничивается классом MyClass и интерфейсом MyInterface.
Таким образом, любой тип, передаваемый параметру Т, должен быть подклассом, производным от класса MyClass и реализующим 
интерфейс MyInterface. 

Применение метасимвольных аргументов (Wildcard)
Метасимвольный аргумент обозначается знаком ? и предсьтавляет собой неизвестный тип. 

Ограниченные метасимвопьные аргументы
Метасимвольные аргументы могут быть ограничены почти таким же образом, как и параметры типов. Ограничивать
метасимвольный аргумент особенно важно при создании обобщенного типа, оперирующего иерархией классов.
чтобы установить верхнюю границу для метасимвола, следует воспользоваться приведенной ниже формой метасимвольного выражения:
<? extends суперкласс>

Имеется также возможность указать нижнюю границу для метасимвольного аргумента, введя оператор super в его объявление. 
Ниже приведена общая форманаложения ограничения на метасимвольный аргумент снизу. 
<? super nодклаасс>
В данном случае допустимыми аргументами могут быть только те классы, которые являются суперклассами для указанного 
подкласса . Это исключающее выражение, поскольку оно не включает в себя заданный подкласс.

Соэдание обобщенного метода
static <Т extends Comparable<T>, V extends Т> boolean is!n (T х, V[] у){}
Параметр типа объявляется до типа, возвращаемого методом.
обобщенные методы могут быть как статическими, так и нестатическими.
Никаких ограничений на этот счет не существует.
    
Обобщенные конструкторы
Конструкторы также могут быть обобщенными, даже если их классы таковыми не являются.

class GenCons {
private double val ;
<Т extends Number> GenCons (T arg ) {
val = ar. doubleValue ();
}}

Обобщенные интерфейсы
Помимо классов и методов, обобщенными можно объявлять интерфейсы. Обобщенные интерфейсы объявляются таким же образом, 
как и обобщенные классы.
interface MinMax<T extends ComparaЬle<T>>
class MyClass<T extends ComparaЫe<T>> implements Minмax<T>
Если класс реализует конкретный тип обобщенного интерфейса, то реализующий класс не обязан быть обобщенным
class MyClass implements MinМax<Integer>

Обобщенный интерфейс дает два преимущества. Во-первых, он может быть реализован для разных типов данных. И во-вторых, 
он позволяет наложить ограничения на типы данных, для которых он может быть реализован. 

При компиляцииприкладного кода jаvа все сведения об обобщенных типах удаляются (стираются). Это означает, что параметры 
типа сначала заменяются их ограничивающим типом, которым является тип Obj e ct, если никакого явного ограничения не 
указано. Затем выполняется требуемое приведение типов, определяемое аргументами типа, для обеспечения совместимости с 
типами, указанными в этих аргументах. Компилятор также обеспечивает эту совместимость типов. Такой подход к обобщениям 
означает, что никаких сведений о типах во время выполнения не существует. Это просто механизм автоматической обработки 
исходного кода.

Мостовые методы
Иногда компилятору приходится вводить в класс так называемый мостовой метод в качестве выхода из положения в тех случаях, 
когда результат стирания типов в перегружаемом методе из подкласса не совпадает с тем, что получается при стирании в 
аналогичном методе из суперкласса. В этом случае со3Дается метод, который использует стирание типов в суперклассе и 
вызывает соответствующий метод из подкласса с указанным стиранием типов.

Ошибки неоднозначности
Ошибки неоднозначности происходят, когда стирание типов приводит к тому, что два внешне разных объямения обобщений
разрешают один и тот же стираемый тип, вызывая конфликт.

Некоторые ограничения, присущие обобщениям 
1) Получить экземпляр по параметру типа неnьэя (Создать экземпляр по параметру типа нельзя.)
оЬ = пеw Т(); // Недопустимо !!!

2) Ограничения на статические чпены. Ни в одном из статических членов нельзя использовать параметр типа, 
объявляемый в его классе.

3) Ограничения на обобщенные массивы
Имеются два важных ограни чения, накладываемые на обобщения и касающиеся массивов. Во-первых, нельзя создать экземпляр 
массива, тип элемента которого определяется параметром типа. И во-вторых, нельзя создать массив специфических для типа 
обобщенных ссылок.

Gen (Т о, Т[] nums) {
оЬ = о; 
vals = new Т[10];

Ограничения на обобщенные исключения
Обобщенный класс не может расширять класс Throwable. Это означает, что
создать обобщенные классы исключений нельзя. 

