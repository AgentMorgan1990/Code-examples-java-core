1) todo разобрать CompletableFuture
2) todo разобрать пример с notify()
3) Расписать тут все основные методы работы с многопоточкой

Существуют два отдельных вида многозадачности: многозадачность на основе процессов и многозадачность на основе потоков.
Важно понимать, в чем состоит отличие этих видов многозадачности. Большинству читателей лучше известна многозадачность
на основе процессов. Працесс, по существу, является выполняющейся программой. Следовательно, многозадачностъ на основе
процессов - это средство, которое позволяет одновременно выполнять две или несколько программ на компьютере. Так,
многозадачность на основе процессов позволяет запускать компилятор Java, работая одновременно в текстовом редакторе или
посещая веб-сайт. В среде многозадачности на основе процессов программа оказывается наименьшей единицей кода, которую
может диспетчеризировать планировщик операционной системы.
В среде многозадачности на основе потаков наименьшей единицей диспетчеризируемого кода является поток исполнения. Это
означает, что одна программа может выполнять две или несколько задач одновременно. Например, текстовый редактор может
форматировать текст в то время, как выполняется его вывод на печать, при условии, что оба эти действия выполняются в
двух отдельных потоках исполнения. Таким образом, многозадачность на основе процессов имеет дело с "общей картиной",
тогда как многозадачность на основе потоков - с отдельными с деталями.

Класс Thread и интерфейс Runnable
Многопоточная система в Java построена на основе класса Thread, его методах и дополняющем его интерфейсе Runnable. Класс
Thread инкапсулирует поток исполнения. Обратиться напрямую к нематериальному состоянию работающего потока исполнения
нельзя, поэтому приходится иметь дело с его "заместителем" - экземпляром класса Thread, который и породил его. Чтобы
создать новый поток исполнения, следует расширить класс Thread или же реализовать интерфейс Runnable.
В классе Thread определяется ряд методов, помогающих управлять потоками исполнения.

qetName         - Получает имя потока исполнения
qetPriority     - Получает приоритет потока исполнения
isAlive         - Определяет, выполняется ли поток
join            - Ожидает завершения потока исполнения
run             - Задает точку входа в поток исполнения
sleep           - Приостанавливает выполнение потока на заданное время
start           - Запускает поток исполнения, вызывая его метода run ()

Главный поток исполнения
Когда программа нa Java запускается на выполнение, сразу же начинает выполняться один поток. Он обычно называется
главным потоком программы, потому что он запускается вместе с ней. Главный поток исполнения важен по двум причинам.
• От этого потока исполнения порождаются все дочерние потоки.
• Зачастую он должен быть последним потоком, завершающим выполнение программы, поскольку в нем производятся различные завершающие действия.

Несмотря на то что главный поток исполнения создается автоматически при запуске программы, им можно управлять через
объект класса Thread. Для этого достаточно получить ссылку на него, вызвав метод currentThread () , который объявляется
как открытый и статический (public static) в классе Thread. Его общая форма выглядит следующим образом:
static Тhread currentТhread ()
Этот метод возвращает ссылку на тот поток исполнения, из которого он был вызван. Получив ссылку на главный поток,
можно управлять им таким же образом, как и любым другим потоком исполнения.
Группа потоков исполнения - это структура данных, которая управляет состоянием всего ряда потоков исполнения в целом.

Соэдание потока исполнения
В наиболее общем смысле для создания потока исполнения следует получить экземпляр объекта типа Thread. В языке Java этой
цели можно достичь следующими двумя способами:
реализовав интерфейс Runnable;
расширив класс Thread.

Реализация и нтерфейса Runnable
Самый простой способ создать поток исполнения состоит в том, чтобы объявить класс, реализующий интерфейс Runnable. Этот
интерфейс предоставляет абстракцию единицы исполняемого кода. Поток исполнения можно создать из объекта любого класса,
реализующего интерфейс Runnable. Для реализации интерфейса Runnable в классе должен быть объявлен единственный метод run():
public void run ()
В теле метода run () определяется код, который, собственно, и составляет новый поток исполнения. Однако в методе run ()
можно вызывать другие методы, использовать другие классы, объявлять переменные таким же образом, как и в главном потоке
исполнения. Единственное отличие заключается в том, что в методе run () устанавливается точка входа в другой,
параллельный поток исполнения в программе. Этот поток исполнения завершится, когда метод run ( ) возвратит управление.
После создания класса, реализующего интерфейс Runnable, в этом классе следует получить экземпляр объекта типа Thread.
Для этой цели в классе Thread определен ряд конструкторов. Тот конструктор, который должен использоваться в данном случае,
выглядит в общей форме следующим образом:
Тhread (Runnable объект_потока , String имя_потока)
После того как новый поток исполнения будет создан, он не запускается до тех пор, пока не будет вызван метод start () ,
объявленный в классе Thread. По существу, в методе start () вызывается метод run (). Ниже показано, каким образом
объявляется метод start ().
void start ()

Расширение класса Тhread
Еще один способ создать поток исполнения состоит в том, чтобы сначала объявить класс, расширяющий класс Thread, а затем
получить экземпляр этого класса. В расширяющем классе должен быть непременно переопределен метод run () , который
является точкой входа в новый поток исполнения. Кроме того, в этом классе должен быть вызван метод start () для запуска
нового потока на исполнение.

Выбор способа создания потоков исполнения
В связи с изложенным выше могут возникнуть следующие вопросы: почему в java предоставляются два способа для создания
порождаемых потоков исполнения и какой из них лучше? Ответы на эти вопросы взаимосвязаны. В классе Thread определяется
ряд методов, которые могут быть переопределены в производных классах. И только один из них должен быть штременио
переопределен: метод run (). Безусловно, этот метод требуется и в том случае, когда реализуется интерфейс RunnaЫe.
Многие программирующие нa java считают, что классы следует расширять только в том случае, если они должны быть
усовершенствованы или каким-то образом видоизменены. Следовательно, если ни один из других методов не переопределяется
в классе Thread, то лучше и проще реализовать интерфейс RunnaЫe. Кроме того, при реализации интерфейса RunnaЫe класс
порождаемого потока исполнения не должен наследовать класс Thread, что освобождает его от наследования другого класса.
В конечном счете выбор конкретного способа для создания потоков исполнения остается за вами. Тем не менее в примерах,
приведенных далее в этой главе, потоки будут создаваться с помощью классов, реализующих интерфейс RunnaЫe.

Применение методов isAlive() и join()
Метод isAlive() возвращает логическое значение true, если поток, для которого он вызван, еще исполняется.
В противном случае он возвращает логическое значение false.
В классе Thread имеется метод join(), который применяется чаще, чем метод isAlive(), чтобы дождаться завершения потока исполнения.
Этот метод ожидает завершения того потока исполнения, для которого он вызван. Его имя отражает следующий принцип:
вызывающий поток ожидает, когда указанный поток присоединится к нему. Дополнительные формы метода jоin() позволяют
указывать максимальный промежуток времени, в течение которого требуется ожидать завершения указанного потока исполнения.


Приоритеты потоков
Каждому потоку исполнения в Java присваивается свой приоритет, который определяет поведение данного потока по отношению
к другим потокам. Приоритеты потоков исполнения задаются целыми числами, определяющими относительный приоритет одного
потока над другими. Абсолютное значение приоритета еще ни о чем не говорит, поскольку высокоприоритетный поток не
выполняется быстрее, чем низкоприоритетный, когда он является единственным исполняемым потоком в данный момент.

Чтобы установить приоритет потока исполнения, следует вызвать метод setPriority () из класса Thread. Его общая форма
выглядит следующим образом:
final void setPriority (int уровенъ)
где аргумент уровень обозначает новый уровень приоритета для вызывающего потока исполнения. Значение аргумента уровень
должно быть в пределах от MIN_PRIORITY до МAX_PRIORITY. В настоящее время эти значения равны соответственно 1 и 10.
Чтобы возвратить потоку исполнения приоритет по умолчанию, Следует указать значение NORМ_PRIORIТУ, которое в настоящее время равно 5.

Разные реалИзации Jаvа моrут вести себя совершенно иначе в отношении планирования потоков исполнения. Большинство
несоответствий возникает при наличии потоков исполнения, опирающихся на вытесняющую многозадачность вместо совместного
использования времени ЦП. Наиболее безопасный способ получить предсказуемое межплатформенное поведение многопоточных
программ на Java состоит в том, чтобы использовать потоки исполнения, которые добровольно уступают управление ЦП.

Синхронизация
Когда два или более потока исполнения имеют доступ к одному совместно используемому ресурсу, они нуждаются в гарантии,
что ресурс будет одновременно использован только одним потоком. Процесс, обеспечивающий такое поведение потоков
исполнения, называется синхронизацией.

Ключом к синхронизации является понятие монитора. Монитор - это объект, используемый в качестве взаимоисключающей
блокировки. Только один поток исполпения может в одно и то же время владетъ монитором. Когда поток исполнения запрашивает
блокировку, то говорят, что он входит в монитор. Все другие потоки исполнения, пытающиеся войти в заблокированный монитор,
будут приостановлены до тех пор, пока первый поток не выйдет из монитора. Обо всех прочих потоках говорят, что они
ожидают монитор. Поток, владеющий монитором, может, если пожелает, повторно войти в него. Синхронизировать прикладной
код можно двумя способами, предусматривающими использование ключевого слова synchronized.

Для монитора в java отсутствует отдельный класс вроде Monitor. Вместо этого у каждого объекта имеется свой неявный
монитор, вход в который осуществляется автоматически, когда для этого объекта вызывается синхронизированный метод.
Когда поток исполнения находится в теле синхронизированного метода, ни один другой поток исполнения не может вызвать
какой-нибудь другой синхронизированный метод для того же самого объекта. Это позволяет писать очень ясный и краткий
многопоточный код, поскольку поддержка синхронизации встроена в язык.

Оператор synchronized
Синхронизированные методы
Синхронизированные блоки кода

